
% SkyLib_image (beta) made for use in the Star Haven battle jam submission "This is how we mod Paper Mario" by Rain(chus) & ShyBlook(ster137)
% SkyLib_image credits - Engineering/asm: ShyBlook | scripts & whatnot for ROM image injection among other suggestions and advice: Rain <3

#reserve 00000010 $CustomFXRomBuffer    % 16 bytes, enough to hold 4 pointers
%#reserve 00012C00 $ImageBuffer          % 76.800 Bytes (enough for a single 320x240 CI8 image)

#reserve 00004000 $ImageBuffer_0        %  0x307A - 12.410 Bytes, geno_blast_beams | 0x4000 - 16.384 Bytes
#reserve 00004000 $ImageBuffer_1        %  0x1540 - 5.440  Bytes, geno_blast_smoke


#new:Data $plt_GenoBlast { ~PaletteFile:CI-4:geno_blast_00.png }
#new:Data $plt_GenoBlast_charge { ~PaletteFile:CI-4:geno_blast_charge_palette.png }
#new:Data $plt_GenoBlast_smoke { ~PaletteFile:CI-4:geno_blast_smoke_palette.png }

#export:Data $anm_GenoBlast {  % animation header [32 Bytes] | Animation Headers are pre-defined and cannot be edited at runtime. This is subject to change
/% 0x00 %/ 8008EFF0         % spriteTable* | Could technically cut this but maybe it'll be relevant in the future
/% 0x04 %/ $plt_GenoBlast   % spritePalette*
/% 0x08 %/ 170`s            % spriteWidth
/% 0x0A %/ 146`s            % spriteHeight
/% 0x0C %/ ~TileFormat:CI-4 % format
/% 0x10 %/ ~TileDepth:CI-4  % depth
/% 0x14 %/ 46`s             % numFrames
/% 0x16 %/ 0000s            % imageTableOffset
/% 0x18 %/ 12410`           % frameByteSize
/% 0x1C %/ .TargetFPS_30    % animationFramerate
/% 0x20 %/ $ImageBuffer_0   % Associated image buffer
}

#export:Data $anm_GenoBlast_smoke {  % Entry #3 - (46+107)*4 offset [612 bytes]
    /% 0x00 %/ 8008EFF0         % spriteTable* | Could technically cut this but maybe it'll be relevant in the future
    /% 0x04 %/ $plt_GenoBlast_smoke   % spritePalette*
    /% 0x08 %/ 170`s            % spriteWidth
    /% 0x0A %/ 64`s             % spriteHeight
    /% 0x0C %/ ~TileFormat:CI-4 % format
    /% 0x10 %/ ~TileDepth:CI-4  % depth
    /% 0x14 %/ 46`s             % numFrames
    /% 0x16 %/ 612`s            % imageTableOffset
    /% 0x18 %/ 5440`            % frameByteSize
    /% 0x1C %/ .TargetFPS_30    % animationFramerate
    /% 0x20 %/ $ImageBuffer_1   % Associated image buffer
}

#export:Data $anm_GenoBlast_charge {  % animation header [32 Bytes] | Animation Headers are pre-defined and cannot be edited at runtime. This is subject to change
    /% 0x00 %/ 8008EFF0         % spriteTable* | Could technically cut this but maybe it'll be relevant in the future
    /% 0x04 %/ $plt_GenoBlast_charge   % spritePalette*
    /% 0x08 %/ 54`s             % spriteWidth
    /% 0x0A %/ 116`s            % spriteHeight
    /% 0x0C %/ ~TileFormat:CI-4 % format
    /% 0x10 %/ ~TileDepth:CI-4  % depth
    /% 0x14 %/ 107`s            % numFrames
    /% 0x16 %/ 00B8s            % imageTableOffset
    /% 0x18 %/ 3132`            % frameByteSize
    /% 0x1C %/ .TargetFPS_30    % animationFramerate
    /% 0x20 %/ $ImageBuffer_0   % Associated image buffer
}

% If an image has to be pulled from ROM retrieving the actual image goes as follows:
% 1. Load [8008EFF0] where the pointer to the list of ROM pointers is stored
% 2. Load a word from that address to retrieve the ROM address

%#new:Data $TESTDATA { ~Flags:AnimFlags:Loop|TargetFPS_15|Test_1|Test_2|Test_3 } % 3181 8443


#new:Function $update_custom_fx_anim_frame 
{
    PUSH    RA, S0, S1

    LA      S0, $ActiveCustomFX     % Set S0 = CustomFX struct
    ADDU    T2, R0, R0              % Set loop counter = 0

    .Loop
    LW      S1, 0000 (S0)           % Set S1 = anim header
    BEQ     S1, R0, .SKIP           % If anim header = 0, skip entry
    NOP

    LBU     T1, 0006 (S0)           % Set T1 = frame timer


    SLTI    T4, T1, 1`              % If frame timer < 1 -> T4 = 1, else T4 = 0

    BNEL    T4, R0, .ADVANCEFRAME   % If frame timer == 0, branch
    LHU     T0, 0004 (S0)           % Set T0 = current frame index

    ADDIU   T1, T1, -1`             % Advance frame timer
    BEQ     R0, R0, .SKIP
    SB      T1, 0006 (S0)           % Update frame timer

    .ADVANCEFRAME
    LW      T5, 001C (S1)           % Set T5 = anim framerate timer val
    SB      T5, 0006 (S0)           % Update frame timer
    
    ADDIU   T0, T0, 1`              % Advance frame
    LHU     T1, 0014 (S1)           % Set T1 = frame total
    SLT     T4, T0, T1              % If currentFrame < totalFrames -> T4 = 1; else T4 = 0
    
    BNEL    T4, R0, .SKIP           % If T4 != 0 the animation has not yet concluded
    SH      T0, 0004 (S0)           % Store new frame    

    % We land here if currentFrame >= totalFrames, meaning we gotta delete this entry (or loop and set frame to 0 if that ever gets implemented)
    SW      R0, 0000 (S0)           % Clear bytes 0-3
    SW      R0, 0004 (S0)           % Clear bytes 4-7
    SW      R0, 0008 (S0)           % Clear bytes 8-B

    .SKIP
    ADDIU   S0, S0, 12`             % Offset pointer to check next slot
    SLTI    T4, T2, 3`              % If loop counter < 3 -> T4 = 1, else T4 = 0

    BNEL    T4, R0, .Loop           % We loop if the loop counter was below 3     
    ADDIU   T2, T2, 1`              % Increment loop counter on branch


    POP     RA, S0, S1
    JR      RA
    LI      V0, 2
}

#new:Function $update_custom_fx_rom_buffer % This is to be called inbetween 'update_custom_fx_anim_frame' and 'render_custom_fx' | DONE; TEST
{
    PUSH    RA, S0, S1, S2

    LA      S0, $ActiveCustomFX
    LA      S1, $CustomFXRomBuffer
    ADDU    S2, R0, R0          % Set Loop_counter = 0 

    .Loop
    LW      T5, 0000 (S0)       % Set T5 = animationHeader

    BEQ     T5, R0, .SKIP       % If animationHeader = 0 we can skip this slot
    NOP
    LW      T0, 0000 (T5)       % Set T0 = 8008EFF0. Can't be in the delay slot as loading from address 0000 0000 crashes

    LW      T0, 0000 (T0)       % Load ROM_pointer from 8008EFF0

    LHU     T1, 0004 (S0)       % Set T1 = currentFrameIndex
    SLL     T2, T1, 2           % Set T2 = currentFrameIndex*4
    ADDIU   T3, T1, 1           % Set T3 = currentFrameIndex + 1
    SLL     T4, T3, 2           % Set T4 = (currentFrameIndex + 1)*4

    LHU     T5, 0016 (T5)       % Set T5 = imageTableOffset
    ADDU    T0, T0, T5          % T0 = ROM_pointer + imageTableOffset

    ADDU    A0, T0, T2          % DMA Start = (ROM_pointer + imageTableOffset) + currentFrameIndex*4
    ADDU    A1, T0, T4          % DMA End   = (ROM_pointer + imageTableOffset) + (currentFrameIndex + 1)*4

    JAL     ~Func:dma_copy      % This should always DMA 4 bytes aka a single ROM address, the one of our current frame
    ADDU    A2, R0, S1

    .SKIP
    ADDIU   S0, S0, 12`         % Offset pointer to check next slot
    ADDIU   S1, S1, 4`          % Advance AddressBuffer by 1 entry
    SLTI    T4, S2, 3`          % If loop counter < 3 -> T4 = 1, else T4 = 0

    BNEL    T4, R0, .Loop       % We loop if the loop counter was below 3     
    ADDIU   S2, S2, 1`          % Increment loop counter on branch

    %%% What to do from here: use rom address to dma the actual image, render it, loop.
    %%% Implement loop for iterating through $ActiveCustomFX (probably will have 8 entries total.) 
    %%% Each slot's state will be determined by the first entry (animHeader*, inactive if 0)
    %%% It gets unset by this function as soon as the desired amount of loops has been reached (usually 1.)
    %%% Alternatively, a different API function (API_ClearCustomFX[ID]) would be able to unset the flag of the specified slot
    
    POP     RA, S0, S1, S2
    JR      RA
    LI      V0, 2
}

#new:Function $render_custom_fx % Render call for custom fx entries. | DONE; TEST
{
    ADDIU   SP, SP, -50
    SW      RA, 004C (SP)
    SW      S0, 0048 (SP)
    SW      S1, 0044 (SP)
    SW      S2, 0040 (SP)
    SW      S3, 003C (SP)

    LA      S0, $ActiveCustomFX     % Set S0 = CustomFX struct
    LA      S3, $CustomFXRomBuffer  % Set S1 = RomBuffer
    ADDU    S2, R0, R0              % Set loop counter = 0   

    .Loop
    LW      S1, 0000 (S0)           % Set S1 = animationHeader
    BEQ     S1, R0, .SKIP           % Skip slot if the header* is 0 aka empty
    NOP

    %%% DMA IMAGE FROM ROM ADDRESS
    LW      A0, 0000 (S3)           % Load rom address of current image
    LW      T0, 0018 (S1)           % Load size of image in bytes
    LW      A2, 0020 (S1)           % Load image buffer to use

    %%% Image Buffer is not read until later into the frame so we can't occupy the same space or else graphical issues occur
    %ADDIU   T2, R0, 4B00            % T2 = 19.200 (1/4th of image buffer)
    %MULTU   S2, T2
    %MFLO    V0
    %ADDU    A2, A2, V0              % Add offset to image buffer address
    %ADDU    S3, A2, R0              % Copy buffer address with offset into S3

    JAL     ~Func:dma_copy
    ADDU    A1, A0, T0              % Set A1 = rom_address + image_byte_size

    %%% RENDER DMA'D IMAGE      todo: Set S1 back to animationHeader
    %COPY    A0, S3
    LW      A0, 0020 (S1)           % Set A0 = dma'd image
    LHU     A1, 0008 (S1)           % Set sprite width arg
    LHU     A2, 000A (S1)           % Set sprite height arg
    LW      A3, 000C (S1)           % Set sprite image format arg

    LW      T0, 0010 (S1)           % Load sprite tile depth
    SW      T0, 0010 (SP)           % Set tile depth arg

    LW      T0, 0004 (S1)           % Load sprite palette
    SW      T0, 0014 (SP)           % Set sprite palette arg

    LHU     T0, 0008 (S0)           % Load sprite x_pos
    LHU     T1, 000A (S0)           % Load sprite y_pos
    SW      T0, 0018 (SP)           % Set sprite x_pos arg
    SW      T1, 001C (SP)           % Set sprite y_pos arg


    % Set clipping (currently just uses standard values aka entire screen)
    SW      R0, 0020 (SP)           % set clipULx = 0
    SW      R0, 0024 (SP)           % set clipULy = 0
    ADDIU   T0, R0, 320`
    ADDIU   T1, R0, 240`
    SW      T0, 0028 (SP)           % set clipLRx = 320
    SW      T1, 002C (SP)           % set clipLRy = 240

    LBU     T0, 0007 (S0)           % Load sprite opacity
    SW      T0, 0030 (SP)           % set sprite opacity arg

    JAL     ~Func:draw_ci_image_with_clipping
    NOP


    .SKIP
    ADDIU   S0, S0, 12`         % Offset pointer to check next slot
    ADDIU   S3, S3, 4`          % Advance AddressBuffer by 1 entry
    SLTI    T4, S2, 3`          % If loop counter < 3 -> T4 = 1, else T4 = 0

    BNEL    T4, R0, .Loop       % We loop if the loop counter was below 3     
    ADDIU   S2, S2, 1`          % Increment loop counter on branch


    LW      RA, 004C (SP)
    LW      S0, 0048 (SP)
    LW      S1, 0044 (SP)
    LW      S2, 0040 (SP)
    LW      S3, 003C (SP)
    JR      RA
    ADDIU   SP, SP, 50
}


#export:Function $API_PlayCustomFX % IN: animation_header, x_pos, y_pos, opacity | OUT: FX_ID (Slot # in $ActiveCustomFX struct) | DONE
{
    PUSH    RA, S0, S1

    LW      S0, 000C (A0)       % Load script context because it'll be needed later no matter the outcome
    LA      S1, $ActiveCustomFX % Load the CustomFX struct
    ADDU    T2, R0, R0          % Make sure T2 = 0 [This will be the loop counter]

    .Loop
    LW      T0, 0000 (S1)       % Load first word of the current slot. If it's equal to 0000 0000 the slot is free
    
    BNEL    T0, R0, .Occupied   % Check for available FX slot
    ADDIU   S1, S1, 12`         % Add offset to check next entry if the slot was occupied

    .SlotFound
    JAL     ~Func:get_variable
    LW      A1, 0000 (S0)       % Load animationHeader*
    SW      V0, 0000 (S1)       % Store animationHeader*

    LW      T0, 001C (V0)       % Load animationTargetFPS
    SB      T0, 0006 (S1)       % Set animationTargetFPS for newly added anim entry

    JAL     ~Func:get_variable
    LW      A1, 0004 (S0)       % Load x_pos
    SH      V0, 0008 (S1)       % Store x_pos

    JAL     ~Func:get_variable
    LW      A1, 0008 (S0)       % Load y_pos
    SH      V0, 000A (S1)       % Store y_pos

    JAL     ~Func:get_variable
    LW      A1, 000C (S0)       % Load opacity
    SB      V0, 0007 (S1)       % Store opacity

    BEQ     R0, R0, .END
    ADDU    A2, R0, T2          % A2 = Loop counter (Loop counter will be equal to the current slot ID which we want to return)


    .Occupied
    SLTI    T4, T2, 3`          % If loop counter < 3 -> T4 = 1, else T4 = 0

    BNEL    T4, R0, .Loop       % We loop if the loop counter was below 3     
    ADDIU   T2, T2, 1`          % Increment loop counter on branch

    % We're here if T4 was 0 aka the loop counter was at 3 meaning every available slot in the FX struct is occupied
    ADDIU   A2, R0, FF          % Set A2 = FF to return as the FX_ID as there was no slot available

    .END
    JAL     ~Func:set_variable
    LW      A1, 0010 (S0)       % Load target to set

    POP     RA, S0, S1
    JR      RA
    LI      V0, 2
}
% Tested lightly, appears to work fine.


#export:Function $API_DEBUG_DumpCustomFXEntryBySlotID % IN: Slot ID | OUT: animHeader*, currentFrame/opacity/fpsTimer, x_pos/y_pos
{
    PUSH    RA, S0, S1

    LW      S0, 000C (A0)       % Load script context
    LA      S1, $ActiveCustomFX % Load struct

    JAL     ~Func:get_variable
    LW      A1, 0000 (S0)       % Get Slot ID

    % This is faster than multiplication and for a chunk that potentially can execute up to 4 times a frame I will hook up with my lover Shift Left Logical.
    SLL     T0, V0, 4           % Set T0 = SlotID*16
    SLL     T1, V0, 2           % Set T1 = SlotID*4
    SUBU    T2, T0, T1          % Set T2 = SlotID*16 - SlotID*4 (This is to calculate an offset of 12 bytes)
    ADDU    S1, S1, T2          % Add the calculated offset to our pointer

    LW      A2, 0000 (S1)       % Load animHeader*
    JAL     ~Func:set_variable
    LW      A1, 0004 (S0)

    LW      A2, 0004 (S1)       % Load currentFrame/fpsTimer/opacity
    JAL     ~Func:set_variable
    LW      A1, 0008 (S0)

    LW      A2, 0008 (S1)       % Load x_pos/y_pos
    JAL     ~Func:set_variable
    LW      A1, 000C (S0)

    POP     RA, S0, S1
    JR      RA
    LI      V0, 2
}

@Hook 82760 %800E92B0 | This hook pretty much acts as the Update function for this whole system
{

%%% SkyLib_image functions
JAL     $update_custom_fx_anim_frame
NOP
JAL     $update_custom_fx_rom_buffer
NOP
JAL     $render_custom_fx
NOP


%%% SkyLib_audio functions
JAL     $update_streaming_audio
NOP
%JAL     $play_instrument
%NOP

.END
LW      S7, 0084 (SP)
LW      S6, 0080 (SP)
J       800E92B8
LW      RA, 008C (SP)
}